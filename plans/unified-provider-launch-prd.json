{
  "projectName": "Brain Dump - Unified AI Provider Launch System",
  "projectPath": "/home/xtra/code/personal_projects/brain-dump",
  "projectId": "cb902fab-9e9c-472d-ad73-d5f5352780aa",
  "epicId": "epic-decc42e3e2ea",
  "epicTitle": "Unified AI Provider Launch System",
  "epicDescription": "Create a unified launch UI that shows all AI providers (Claude Code, VS Code, Cursor, OpenCode) with a Ralph (autonomous) mode toggle for each. Uninstalled providers are shown grayed out with installation links.\n\n## Key Features\n\n- Single unified launch panel showing all 4 providers\n- Provider detection (installed vs. uninstalled)\n- Ralph mode toggle per provider\n- Graceful handling of uninstalled providers (grayed out, install links)\n- 2x2 grid layout with consistent UX\n- Remembers last used provider\n\n## Technical Scope\n\n- Provider detection API\n- Unified launch routing system\n- React hooks for provider status\n- New launch panel component\n- Integration with existing ticket detail views\n- Deprecation of old LaunchActions component",
  "userStories": [
    {
      "id": "ticket-d6886ac5cdf0",
      "title": "Create provider type system and constants",
      "description": "## Overview\n\nCreate the foundational type system for AI providers, establishing the single source of truth for provider configuration.\n\n## Types\n\n```typescript\nexport type AIProvider = \"claude-code\" | \"vscode\" | \"cursor\" | \"opencode\";\nexport type LaunchMode = \"interactive\" | \"ralph\";\n\nexport interface ProviderConfig {\n  id: AIProvider;\n  name: string;\n  description: string;\n  icon: React.ComponentType<{ className?: string }>;\n  supportsRalph: boolean;\n  installUrl?: string;\n  cliCommand?: string;\n}\n\nexport const PROVIDER_CONFIGS: Record<AIProvider, ProviderConfig>;\n```\n\n## Implementation Guide\n\n### Step 1: Create the types file\n\n**Files:** `src/lib/providers.ts`\n\n1. Define the `AIProvider` union type for the 4 providers\n2. Define the `LaunchMode` type for interactive vs Ralph mode\n3. Create the `ProviderConfig` interface with all required fields\n4. Export the `PROVIDER_CONFIGS` constant with full configuration for each provider\n\n### Step 2: Icon imports\n\nImport from lucide-react:\n- Claude Code: `Sparkles`\n- VS Code: `Code2`\n- Cursor: `MousePointer2`\n- OpenCode: `Terminal`\n\n## Design Decisions\n\n### Why centralized config object vs distributed?\n\n1. **Single source of truth**: All provider metadata in one place\n2. **Type safety**: Prevents typos and ensures consistency\n3. **Easier testing**: Mock the entire config object\n4. **Future extensibility**: Easy to add new providers\n\n## Acceptance Criteria\n\n- [ ] `AIProvider` type includes all 4 providers\n- [ ] `PROVIDER_CONFIGS` object is fully populated with icons, names, descriptions\n- [ ] All providers marked `supportsRalph: true`\n- [ ] Install URLs provided for all providers\n- [ ] Type exports available for other files to import\n\n## References\n\n- See `src/lib/schema.ts` for existing `workingMethod` type pattern\n- Icon components from `lucide-react`",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "types"],
      "passes": false
    },
    {
      "id": "ticket-970c69ccb54b",
      "title": "Implement provider detection API",
      "description": "## Overview\n\nCreate server functions to detect which AI providers are installed on the system by checking for CLI commands and app bundles.\n\n## Types\n\n```typescript\nexport interface ProviderStatus {\n  provider: AIProvider;\n  installed: boolean;\n  version?: string;\n  error?: string;\n}\n\nexport interface AllProviderStatuses {\n  claudeCode: ProviderStatus;\n  vscode: ProviderStatus;\n  cursor: ProviderStatus;\n  opencode: ProviderStatus;\n}\n```\n\n## Implementation Guide\n\n### Step 1: Create detection functions\n\n**Files:** `src/api/provider-detection.ts`\n\nImplement detection for each provider:\n\n```typescript\nasync function detectClaudeCode(): Promise<ProviderStatus> {\n  // Try: claude --version\n  // Return { provider: 'claude-code', installed: boolean, version?: string }\n}\n\nasync function detectVSCode(): Promise<ProviderStatus> {\n  // Try: code --version\n  // Fallback: check app bundle on macOS/Linux\n}\n\nasync function detectCursor(): Promise<ProviderStatus> {\n  // Try: cursor --version\n  // Fallback: check app bundle\n}\n\nasync function detectOpenCode(): Promise<ProviderStatus> {\n  // Copy from existing isOpenCodeInstalled in terminal.ts\n}\n```\n\n### Step 2: Create unified endpoint\n\n```typescript\nexport const getProviderStatuses = createServerFn({ method: \"GET\" })\n  .handler(async (): Promise<AllProviderStatuses> => {\n    const [claudeCode, vscode, cursor, opencode] = await Promise.all([\n      detectClaudeCode(),\n      detectVSCode(),\n      detectCursor(),\n      detectOpenCode(),\n    ]);\n\n    return { claudeCode, vscode, cursor, opencode };\n  });\n```\n\n### Step 3: Add React hook\n\n**Files:** `src/lib/hooks/use-provider-statuses.ts`\n\n```typescript\nexport function useProviderStatuses() {\n  return useQuery({\n    queryKey: [\"provider-statuses\"],\n    queryFn: () => getProviderStatuses(),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n}\n```\n\n## Design Decisions\n\n### Why parallel detection with Promise.all?\n\n1. **Performance**: All 4 checks run simultaneously (200ms vs 800ms sequential)\n2. **User experience**: Faster initial load\n3. **Independence**: One failing check doesn't block others\n\n### Why 5-minute stale time?\n\n1. **Reasonable assumption**: Installations don't happen during active use\n2. **Reduces overhead**: Avoids repeated shell commands\n3. **Manual refresh available**: User can reload if needed\n\n## Acceptance Criteria\n\n- [ ] All 4 detection functions implemented\n- [ ] `getProviderStatuses` returns correct format\n- [ ] React hook caches results for 5 minutes\n- [ ] Error handling for missing commands\n- [ ] Version extraction works when available\n\n## References\n\n- Existing pattern: `src/api/terminal.ts` `isOpenCodeInstalled()`\n- TanStack Query: `src/lib/hooks.ts` for hook patterns",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "api"],
      "passes": false
    },
    {
      "id": "ticket-8bc1332ef58e",
      "title": "Create unified launch API routing",
      "description": "## Overview\n\nConsolidate all launch logic into a single `launchWithProvider` server function that routes to the appropriate handler based on provider + mode combination.\n\n## Types\n\n```typescript\nexport interface LaunchRequest {\n  provider: AIProvider;\n  mode: LaunchMode;\n  ticketId: string;\n  projectPath: string;\n}\n\nexport interface LaunchResult {\n  success: boolean;\n  message: string;\n  pid?: number;\n  error?: string;\n}\n```\n\n## Implementation Guide\n\n### Step 1: Create router function\n\n**Files:** `src/api/launch.ts`\n\n```typescript\nexport const launchWithProvider = createServerFn({ method: \"POST\" })\n  .inputValidator((data: LaunchRequest) => data)\n  .handler(async ({ data }): Promise<LaunchResult> => {\n    const { provider, mode, ticketId, projectPath } = data;\n\n    // Route matrix:\n    // claude-code + interactive â†’ launchClaudeInTerminal\n    // claude-code + ralph â†’ launchRalphForTicket(aiBackend=\"claude\")\n    // vscode + interactive â†’ launchVSCodeInEditor\n    // vscode + ralph â†’ launchVSCodeInEditor with ralph-context.md\n    // cursor + interactive â†’ launchCursorInEditor\n    // cursor + ralph â†’ launchCursorInEditor with ralph-context.md\n    // opencode + interactive â†’ launchOpenCodeInTerminal\n    // opencode + ralph â†’ launchRalphForTicket(aiBackend=\"opencode\")\n\n    if (provider === 'claude-code') {\n      // Existing Claude launch logic\n    } else if (provider === 'vscode') {\n      // New VS Code launch\n    } else if (provider === 'cursor') {\n      // New Cursor launch\n    } else if (provider === 'opencode') {\n      // Existing OpenCode logic\n    }\n  });\n```\n\n### Step 2: Add VS Code launch function\n\n```typescript\nasync function launchVSCodeInEditor(\n  ticketId: string,\n  projectPath: string,\n  mode: LaunchMode\n): Promise<LaunchResult> {\n  // If Ralph mode: generate ralph-context.md\n  if (mode === 'ralph') {\n    await generateRalphContext(ticketId, projectPath);\n  }\n\n  // Launch VS Code: code <projectPath>\n  const result = await spawnDetached('code', [projectPath]);\n  return { success: true, message: 'VS Code launched', pid: result.pid };\n}\n```\n\n### Step 3: Add Cursor launch function\n\nSimilar to VS Code but with `cursor` CLI command.\n\n## Design Decisions\n\n### Why single router vs separate endpoints per provider?\n\n1. **Type safety**: Single validation point for all launches\n2. **Consistency**: All launches follow same contract\n3. **Easier testing**: Mock one function instead of 8\n4. **Future extensibility**: New providers = new case, not new endpoint\n\n### Why context file for VS Code/Cursor Ralph mode?\n\n1. **No native Ralph support**: These IDEs don't have autonomous agent mode\n2. **Manual workflow**: User reads context, implements manually\n3. **Consistency**: Same workflow as interactive mode, just more detail\n\n## Acceptance Criteria\n\n- [ ] `launchWithProvider` handles all 8 combinations (4 providers Ã— 2 modes)\n- [ ] Claude Code launches correctly (interactive + Ralph)\n- [ ] VS Code launches with `code` CLI\n- [ ] Cursor launches with `cursor` CLI\n- [ ] OpenCode launches correctly (interactive + Ralph)\n- [ ] Ralph mode generates context file for VS Code/Cursor\n- [ ] Error handling for missing CLIs\n- [ ] Returns consistent `LaunchResult` format\n\n## References\n\n- Existing: `src/api/terminal.ts` `launchClaudeInTerminal`\n- Existing: `src/api/ralph.ts` `launchRalphForTicket`\n- Pattern: `src/api/terminal.ts` `spawnDetached` helper",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "api"],
      "passes": false
    },
    {
      "id": "ticket-7dfeb1cafcd1",
      "title": "Create UnifiedLaunchPanel component",
      "description": "## Overview\n\nBuild the main UI component that displays all 4 AI providers in a 2Ã—2 grid with Ralph mode toggles and launch buttons.\n\n## Implementation Guide\n\n### Step 1: Component structure\n\n**Files:** `src/components/tickets/UnifiedLaunchPanel.tsx`\n\n```tsx\ninterface UnifiedLaunchPanelProps {\n  ticketId: string;\n  projectPath: string;\n  onLaunch?: (provider: AIProvider, mode: LaunchMode) => void;\n}\n\nexport function UnifiedLaunchPanel({ ticketId, projectPath, onLaunch }: UnifiedLaunchPanelProps) {\n  const { data: statuses, isLoading } = useProviderStatuses();\n  const [ralphMode, setRalphMode] = useState<Record<AIProvider, boolean>>({\n    'claude-code': false,\n    'vscode': false,\n    'cursor': false,\n    'opencode': false,\n  });\n\n  // 2Ã—2 grid layout\n  // Each card: icon, name, description, checkbox (Ralph), button (Launch/Install)\n}\n```\n\n### Step 2: Provider card component\n\n```tsx\nfunction ProviderCard({\n  config,\n  status,\n  ralphEnabled,\n  onRalphToggle,\n  onLaunch,\n}: ProviderCardProps) {\n  const isInstalled = status?.installed ?? false;\n\n  return (\n    <div className={cn(\"card\", !isInstalled && \"opacity-50\")}>\n      <Icon className=\"...\" />\n      <h3>{config.name}</h3>\n      <p>{config.description}</p>\n\n      {isInstalled ? (\n        <>\n          <Checkbox checked={ralphEnabled} onChange={onRalphToggle}>\n            Ralph Mode\n          </Checkbox>\n          <Button onClick={() => onLaunch(ralphEnabled ? 'ralph' : 'interactive')}>\n            Launch\n          </Button>\n        </>\n      ) : (\n        <Button variant=\"secondary\" onClick={() => window.open(config.installUrl)}>\n          Install â†’\n        </Button>\n      )}\n    </div>\n  );\n}\n```\n\n### Step 3: Launch handler\n\n```tsx\nconst launchMutation = useMutation({\n  mutationFn: (params: { provider: AIProvider; mode: LaunchMode }) =>\n    launchWithProvider({\n      provider: params.provider,\n      mode: params.mode,\n      ticketId,\n      projectPath,\n    }),\n  onSuccess: () => {\n    toast.success('Launched successfully');\n    onLaunch?.(provider, mode);\n  },\n});\n```\n\n### Step 4: LocalStorage persistence\n\nRemember last Ralph mode selections:\n\n```tsx\nuseEffect(() => {\n  const saved = localStorage.getItem('ralph-mode-prefs');\n  if (saved) setRalphMode(JSON.parse(saved));\n}, []);\n\nuseEffect(() => {\n  localStorage.setItem('ralph-mode-prefs', JSON.stringify(ralphMode));\n}, [ralphMode]);\n```\n\n## Design Decisions\n\n### Why 2Ã—2 grid vs vertical list?\n\n1. **Visual hierarchy**: Grid shows all options at once\n2. **Screen real estate**: More compact than vertical list\n3. **Symmetry**: 4 items fit perfectly in 2Ã—2\n\n### Why per-provider Ralph toggle vs single global?\n\n1. **Flexibility**: User might want Ralph for Claude, interactive for VS Code\n2. **State persistence**: Remembers preferences per provider\n3. **Future extensibility**: Some providers may not support Ralph\n\n## Acceptance Criteria\n\n- [ ] 2Ã—2 grid layout displays all 4 providers\n- [ ] Installed providers show checkbox + Launch button\n- [ ] Uninstalled providers grayed out with Install link\n- [ ] Ralph mode checkbox works for each provider\n- [ ] Launch button triggers correct API call\n- [ ] Loading state while checking provider status\n- [ ] Toast notification on successful launch\n- [ ] LocalStorage persists Ralph mode selections\n- [ ] Responsive design (stacks on mobile)\n\n## References\n\n- Layout inspiration: `src/components/tickets/LaunchActions.tsx`\n- Tailwind grid: `grid grid-cols-2 gap-4`\n- Icons: `lucide-react`",
      "acceptanceCriteria": [],
      "priority": "medium",
      "tags": ["frontend", "ui"],
      "passes": false
    },
    {
      "id": "ticket-8c6e43d2e000",
      "title": "Integrate UnifiedLaunchPanel into ticket detail page",
      "description": "## Overview\n\nReplace the existing `LaunchActions` component with the new `UnifiedLaunchPanel` in the ticket detail page.\n\n## Implementation Guide\n\n### Step 1: Update ticket detail route\n\n**Files:** `src/routes/ticket.$id.tsx`\n\nReplace:\n```tsx\n<LaunchActions ticketId={ticket.id} projectPath={project.path} />\n```\n\nWith:\n```tsx\n<UnifiedLaunchPanel\n  ticketId={ticket.id}\n  projectPath={project.path}\n  onLaunch={(provider, mode) => {\n    // Optional: Update ticket status to \"in_progress\" on launch\n  }}\n/>\n```\n\n### Step 2: Update TicketDetailHeader\n\n**Files:** `src/components/tickets/TicketDetailHeader.tsx`\n\nIf `LaunchActions` is used here, replace similarly.\n\n### Step 3: Remove old component import\n\nRemove:\n```tsx\nimport { LaunchActions } from \"../components/tickets/LaunchActions\";\n```\n\nAdd:\n```tsx\nimport { UnifiedLaunchPanel } from \"../components/tickets/UnifiedLaunchPanel\";\n```\n\n### Step 4: Test all launch scenarios\n\n1. Open a ticket\n2. Verify all 4 providers shown\n3. Test launching each installed provider (interactive + Ralph)\n4. Verify uninstalled providers show install link\n\n## Design Decisions\n\n### Why keep LaunchActions.tsx for now?\n\n1. **Gradual migration**: Allow rollback if issues found\n2. **Reference**: Keep old code for comparison\n3. **Deprecation path**: Mark as deprecated, remove in next cleanup pass\n\n## Acceptance Criteria\n\n- [ ] `UnifiedLaunchPanel` renders in ticket detail page\n- [ ] Old `LaunchActions` component no longer imported\n- [ ] All 4 providers visible in UI\n- [ ] Launch buttons work correctly\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Tests pass\n\n## References\n\n- Existing: `src/routes/ticket.$id.tsx`\n- Existing: `src/components/tickets/TicketDetailHeader.tsx`\n- Pattern: Component replacement without breaking changes",
      "acceptanceCriteria": [],
      "priority": "medium",
      "tags": ["frontend", "integration"],
      "passes": false
    },
    {
      "id": "ticket-cfb3782568bd",
      "title": "Add provider selection to StartEpicModal (optional)",
      "description": "## Overview\n\nEnhance the `StartEpicModal` to allow users to choose their preferred AI provider when starting work on an epic.\n\n**Note:** This is optional and can be deferred if the epic scope is too large.\n\n## Implementation Guide\n\n### Step 1: Add provider field to modal state\n\n**Files:** `src/components/StartEpicModal.tsx`\n\n```tsx\nconst [selectedProvider, setSelectedProvider] = useState<AIProvider | null>(null);\n```\n\n### Step 2: Add provider selection UI\n\nAfter isolation mode selection:\n\n```tsx\n<div className=\"space-y-4\">\n  <h3>Launch With</h3>\n  <RadioGroup value={selectedProvider} onChange={setSelectedProvider}>\n    {Object.entries(PROVIDER_CONFIGS).map(([id, config]) => (\n      <RadioGroup.Option key={id} value={id}>\n        <Icon component={config.icon} />\n        {config.name}\n      </RadioGroup.Option>\n    ))}\n  </RadioGroup>\n</div>\n```\n\n### Step 3: Pass provider to epic start handler\n\n```tsx\nasync function handleStart() {\n  await startEpicWork({\n    epicId,\n    isolationMode,\n    provider: selectedProvider,\n  });\n}\n```\n\n## Design Decisions\n\n### Why optional?\n\n1. **Scope management**: Core feature is ticket detail launch\n2. **User workflow**: Epics less frequently use direct launch\n3. **Complexity**: Epic modal already has isolation mode selection\n\n### Why default provider?\n\n1. **User preference**: Remember last used provider\n2. **Fallback**: Default to Claude Code if no preference\n\n## Acceptance Criteria\n\n- [ ] Provider selection appears after isolation mode\n- [ ] Default provider pre-selected based on user preference\n- [ ] Start button passes provider to backend\n- [ ] UI updates correctly when provider changes\n- [ ] No TypeScript errors\n\n## References\n\n- Existing: `src/components/StartEpicModal.tsx`\n- Pattern: Radio group selection from isolation mode",
      "acceptanceCriteria": [],
      "priority": "low",
      "tags": ["frontend", "enhancement"],
      "passes": false
    },
    {
      "id": "ticket-b4951d0afc1b",
      "title": "End-to-end testing and cleanup",
      "description": "## Overview\n\nPerform comprehensive testing of all provider launch scenarios and deprecate the old `LaunchActions` component.\n\n## Implementation Guide\n\n### Step 1: Manual testing checklist\n\nTest matrix (4 providers Ã— 2 modes = 8 scenarios):\n\n**Claude Code:**\n- [ ] Interactive mode launches Claude in terminal\n- [ ] Ralph mode launches Ralph session\n\n**VS Code:**\n- [ ] Interactive mode opens VS Code\n- [ ] Ralph mode opens VS Code with context file\n\n**Cursor:**\n- [ ] Interactive mode opens Cursor\n- [ ] Ralph mode opens Cursor with context file\n\n**OpenCode:**\n- [ ] Interactive mode launches OpenCode\n- [ ] Ralph mode launches Ralph session\n\n**Uninstalled providers:**\n- [ ] Grayed out correctly\n- [ ] Install link opens in browser\n\n**Edge cases:**\n- [ ] Loading state shows spinner\n- [ ] Error handling shows toast notification\n- [ ] LocalStorage persists Ralph mode toggles\n\n### Step 2: Add E2E test\n\n**Files:** `e2e/launch-providers.spec.ts`\n\n```typescript\ntest('shows all providers in unified panel', async ({ page }) => {\n  await page.goto('/ticket/sample-1');\n\n  // Verify all 4 providers visible\n  await expect(page.getByText('Claude Code')).toBeVisible();\n  await expect(page.getByText('VS Code')).toBeVisible();\n  await expect(page.getByText('Cursor')).toBeVisible();\n  await expect(page.getByText('OpenCode')).toBeVisible();\n});\n\ntest('toggles Ralph mode per provider', async ({ page }) => {\n  await page.goto('/ticket/sample-1');\n\n  const claudeCheckbox = page.locator('[data-provider=\"claude-code\"] input[type=\"checkbox\"]');\n  await claudeCheckbox.check();\n  await expect(claudeCheckbox).toBeChecked();\n\n  // Verify persistence\n  await page.reload();\n  await expect(claudeCheckbox).toBeChecked();\n});\n```\n\n### Step 3: Deprecate LaunchActions\n\n**Files:** `src/components/tickets/LaunchActions.tsx`\n\nAdd deprecation notice:\n\n```tsx\n/**\n * @deprecated Use UnifiedLaunchPanel instead. This component will be removed in the next release.\n */\nexport function LaunchActions(props: LaunchActionsProps) {\n  // Keep implementation for now\n}\n```\n\n### Step 4: Update documentation\n\nAdd to `CLAUDE.md`:\n\n```markdown\n## AI Provider Launch\n\nBrain Dump supports 4 AI development environments:\n\n- **Claude Code** (Anthropic CLI) - Terminal-based\n- **VS Code** - With MCP extension\n- **Cursor** - AI-native editor\n- **OpenCode** - Open source alternative\n\nEach provider supports both interactive and Ralph (autonomous) modes.\n\nLaunch UI: `src/components/tickets/UnifiedLaunchPanel.tsx`\nLaunch API: `src/api/launch.ts`\n```\n\n### Step 5: Run quality checks\n\n```bash\npnpm type-check\npnpm lint\npnpm test\npnpm test:e2e\n```\n\n## Acceptance Criteria\n\n- [ ] All 8 launch scenarios tested and working\n- [ ] E2E tests pass\n- [ ] Type checking passes\n- [ ] Linting passes\n- [ ] Unit tests pass\n- [ ] `LaunchActions` marked as deprecated\n- [ ] Documentation updated in `CLAUDE.md`\n- [ ] No console errors or warnings\n- [ ] Toast notifications work correctly\n- [ ] LocalStorage persistence verified\n\n## References\n\n- Testing patterns: `e2e/` directory\n- Quality checks: `CLAUDE.md` verification section",
      "acceptanceCriteria": [],
      "priority": "medium",
      "tags": ["testing", "cleanup"],
      "passes": false
    },
    {
      "id": "ticket-24c3f1fc-30a0-4562-abba-409ff548c632",
      "title": "EPIC OVERVIEW: Unified AI Provider Launch System",
      "description": "# Unified AI Provider Launch System - Epic Overview\n\n## Problem Statement\n\nThe current launch UI in Brain Dump has inconsistent provider support:\n- `LaunchActions.tsx` has 4 hardcoded options: Claude, Ralph Native, Ralph Docker, OpenCode\n- No VS Code or Cursor as explicit launch options\n- Ralph (autonomous) mode only works with Claude\n- No provider detection (except basic OpenCode check)\n- Users can't easily see which providers they have installed\n\n## Solution\n\nCreate a unified launch UI that:\n1. Shows all AI providers (Claude Code, VS Code, Cursor, OpenCode)\n2. Each provider has a \"Ralph mode\" toggle for autonomous operation\n3. Uninstalled providers are shown grayed out with installation links\n4. Single unified API routes to appropriate handler\n\n## Design Decisions\n\n1. **Show all providers** - Grayed out when not installed, with install links (user preference)\n2. **Grid layout with Ralph toggle** - Each provider card has \"Ralph mode\" checkbox (user preference)\n3. **All providers support Ralph** - Claude, VS Code, Cursor, OpenCode all get Ralph support (user preference)\n4. **Unified API** - Single `launchWithProvider()` server function routes to appropriate handler\n\n## Architecture\n\n### New Files to Create\n\n1. `src/lib/providers.ts` - Type definitions and provider configs\n   ```typescript\n   export type AIProvider = \"claude-code\" | \"vscode\" | \"cursor\" | \"opencode\";\n   export type LaunchMode = \"interactive\" | \"ralph\";\n   \n   export const PROVIDER_CONFIGS: Record<AIProvider, ProviderConfig> = {\n     \"claude-code\": { name: \"Claude Code\", icon: Sparkles, supportsRalph: true, ... },\n     \"vscode\": { name: \"VS Code\", icon: Code2, supportsRalph: true, ... },\n     \"cursor\": { name: \"Cursor\", icon: MousePointer2, supportsRalph: true, ... },\n     \"opencode\": { name: \"OpenCode\", icon: Terminal, supportsRalph: true, ... },\n   };\n   ```\n\n2. `src/api/provider-detection.ts` - Provider detection server functions\n   - `isClaudeCodeInstalled()` - run `claude --version`\n   - `isVSCodeInstalled()` - run `code --version` or check app bundle\n   - `isCursorInstalled()` - run `cursor --version` or check app bundle\n   - `isOpenCodeInstalled()` - run `opencode --version` (existing)\n   - `getProviderStatuses()` - combined endpoint\n\n3. `src/api/launch.ts` - Unified launch server function\n   - `launchWithProvider()` - routes based on provider + mode\n   - `launchVSCodeInEditor()` - Opens VS Code CLI\n   - `launchCursorInEditor()` - Opens Cursor CLI\n\n4. `src/lib/hooks/use-provider-statuses.ts` - React hook for provider status\n\n5. `src/components/tickets/UnifiedLaunchPanel.tsx` - Main UI component\n\n### Files to Modify\n\n1. `src/routes/ticket.$id.tsx` - Use new launch panel\n2. `src/components/tickets/TicketDetailHeader.tsx` - Pass through new props\n3. `src/api/terminal.ts` - Add Cursor launch function\n4. `src/api/ralph.ts` - Ensure all providers work with Ralph mode\n\n### UI Layout\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Start Work With                                                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚\nâ”‚ â”‚ âœ¨ Claude Code       â”‚  â”‚ ğŸ’» VS Code           â”‚                â”‚\nâ”‚ â”‚ Anthropic's CLI      â”‚  â”‚ With MCP extension   â”‚                â”‚\nâ”‚ â”‚ â˜‘ Ralph Mode        â”‚  â”‚ â˜ Ralph Mode        â”‚                â”‚\nâ”‚ â”‚       [Launch]       â”‚  â”‚       [Launch]       â”‚                â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚\nâ”‚ â”‚ ğŸ–± Cursor (dimmed)   â”‚  â”‚ ğŸ’» OpenCode          â”‚                â”‚\nâ”‚ â”‚ Not installed        â”‚  â”‚ Open source agent    â”‚                â”‚\nâ”‚ â”‚ [Install â†’]          â”‚  â”‚ â˜ Ralph Mode        â”‚                â”‚\nâ”‚ â”‚                      â”‚  â”‚       [Launch]       â”‚                â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Ticket Breakdown\n\n| # | Ticket | Priority | Est. Time |\n|---|--------|----------|-----------|\n| 1 | Create provider type system and constants | High | 1-2 hrs |\n| 2 | Implement provider detection API | High | 2-3 hrs |\n| 3 | Create unified launch API routing | High | 3-4 hrs |\n| 4 | Create UnifiedLaunchPanel component | Medium | 3-4 hrs |\n| 5 | Integrate UnifiedLaunchPanel into ticket detail | Medium | 1 hr |\n| 6 | Add provider selection to StartEpicModal | Low | 2 hrs |\n| 7 | End-to-end testing and cleanup | Medium | 2-3 hrs |\n\n**Total estimated time:** 14-19 hours\n\n## Verification Plan\n\n1. Run `pnpm type-check` - should pass\n2. Run `pnpm lint` - should pass\n3. Run `pnpm test` - should pass\n4. Manual testing:\n   - Open ticket detail page\n   - Verify all 4 providers shown\n   - Verify uninstalled providers are grayed out\n   - Test launching each installed provider in interactive mode\n   - Test launching each installed provider in Ralph mode\n   - Verify Ralph mode toggle persists per provider",
      "acceptanceCriteria": [],
      "priority": "low",
      "tags": [],
      "passes": false
    },
    {
      "id": "ticket-4c560850ea9b",
      "title": "Add Cursor to provider enum and new settings fields",
      "description": "## Overview\n\nThe current schema doesn't support Cursor as a working method choice, and lacks settings for the unified launch panel. This ticket adds database-level support for Cursor and new user preferences.\n\n## Types\n\n```typescript\n// In src/lib/schema.ts\nworkingMethod: text(\"working_method\").$type<\"auto\" | \"claude-code\" | \"vscode\" | \"opencode\" | \"cursor\">()\n\n// New settings fields\nhideUninstalledProviders: integer(\"hide_uninstalled_providers\", { mode: \"boolean\" }).default(false),\ndefaultRalphMode: integer(\"default_ralph_mode\", { mode: \"boolean\" }).default(false),\n```\n\n## Implementation Guide\n\n### Step 1: Update schema.ts\n\n**Files:** `src/lib/schema.ts`\n\n1. Find the `projects` table definition\n2. Update `workingMethod` to include `'cursor'` in the type union\n3. Find the `settings` table definition\n4. Update `defaultWorkingMethod` to include `'cursor'`\n5. Add two new fields to `settings`:\n   - `hideUninstalledProviders` (boolean, default false)\n   - `defaultRalphMode` (boolean, default false)\n\n### Step 2: Generate migration\n\n**Command:** `pnpm db:generate`\n\nThis will create a new migration file in `drizzle/` reflecting schema changes.\n\n### Step 3: Run migration\n\n**Command:** `pnpm db:migrate`\n\nThis applies the migration to the database.\n\n### Step 4: Verify\n\n1. Check that existing projects still load correctly\n2. Verify settings page shows new fields\n3. Test that 'cursor' can be selected as a working method\n\n## Design Decisions\n\n### Why add Cursor to enum instead of making it extensible?\n\n1. **Type safety**: TypeScript enums provide compile-time validation\n2. **Known set**: We only support 4 AI providers, not arbitrary ones\n3. **Database constraints**: SQLite can validate enum values at write time\n\n### Why store these as settings rather than project-level?\n\n- `hideUninstalledProviders` is a UI preference (not project-specific)\n- `defaultRalphMode` is a user workflow preference (applies globally)\n\n## Acceptance Criteria\n\n- [ ] Schema updated with 'cursor' in both enums\n- [ ] New settings fields added\n- [ ] Migration generated with `pnpm db:generate`\n- [ ] Migration runs successfully with `pnpm db:migrate`\n- [ ] Existing data not affected\n- [ ] Type checking passes (`pnpm type-check`)\n\n## References\n\n- Related: Ticket B (depends on this for Cursor detection)\n- Schema file: `src/lib/schema.ts`\n- Existing pattern: See how `workingMethod` is currently defined",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "database", "schema", "provider-system"],
      "passes": false
    },
    {
      "id": "ticket-38de23401a4d",
      "title": "Add Cursor CLI detection and launch function",
      "description": "## Overview\n\nCurrently there's no way to detect if Cursor is installed or launch it. This ticket adds detection and launch capabilities parallel to VS Code's implementation.\n\n## Implementation Guide\n\n### Step 1: Add Cursor detection\n\n**Files:** `src/api/terminal-utils.ts`\n\nAdd a new function:\n\n```typescript\nexport async function isCursorInstalled(): Promise<{\n  installed: boolean;\n  version?: string;\n  error?: string\n}> {\n  try {\n    // Try running 'cursor --version'\n    const result = await execAsync('cursor --version');\n    return { installed: true, version: result.stdout.trim() };\n  } catch (error) {\n    // Fallback 1: Check macOS app\n    if (process.platform === 'darwin') {\n      if (existsSync('/Applications/Cursor.app')) {\n        return { installed: true };\n      }\n    }\n\n    // Fallback 2: Check Linux binary\n    if (process.platform === 'linux') {\n      const homeDir = process.env.HOME || '';\n      if (existsSync(path.join(homeDir, '.local/bin/cursor'))) {\n        return { installed: true };\n      }\n    }\n\n    return { installed: false, error: 'Cursor not found' };\n  }\n}\n```\n\n### Step 2: Add Cursor launch function\n\n**Files:** `src/lib/terminal-launcher.ts`\n\nAdd a new function parallel to `launchInVSCode`:\n\n```typescript\nexport async function launchInCursor(\n  projectPath: string,\n  contextFilePath?: string\n): Promise<{ success: boolean; message: string }> {\n  const detection = await isCursorInstalled();\n\n  if (!detection.installed) {\n    return {\n      success: false,\n      message: 'Cursor not installed. Install from cursor.sh'\n    };\n  }\n\n  try {\n    const args = [projectPath];\n    if (contextFilePath) {\n      args.push(contextFilePath);\n    }\n\n    await execAsync(`cursor ${args.join(' ')}`);\n\n    return {\n      success: true,\n      message: `Opened in Cursor: ${projectPath}`\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to launch Cursor: ${error.message}`\n    };\n  }\n}\n```\n\n### Step 3: Add tests\n\n**Files:** `src/api/terminal-utils.test.ts`\n\nAdd tests for `isCursorInstalled()` following the pattern used for VS Code detection.\n\n## Acceptance Criteria\n\n- [ ] `isCursorInstalled()` detects Cursor on macOS and Linux\n- [ ] `launchInCursor()` opens Cursor with project path\n- [ ] Context file is passed to Cursor if provided\n- [ ] Tests added for detection logic\n- [ ] Error messages are user-friendly\n\n## References\n\n- Follow pattern: `launchInVSCode()` in `src/lib/terminal-launcher.ts`\n- Follow pattern: `isVSCodeInstalled()` in `src/api/terminal-utils.ts`",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "provider-system", "cursor"],
      "passes": false
    },
    {
      "id": "ticket-ce4c05d3b18e",
      "title": "Fix VS Code/Cursor launch to update ticket status",
      "description": "## Overview\n\nCurrently `launchInVSCode()` just opens the editor - it doesn't update ticket status, save state files, or create context files. This breaks the end-to-end flow for editor-based launches.\n\nThis ticket creates wrapper functions that properly integrate editor launches with Brain Dump's ticket workflow.\n\n## Implementation Guide\n\n### Step 1: Create wrapper functions\n\n**Files:** `src/api/terminal.ts`\n\nAdd two new server functions:\n\n```typescript\nexport const launchVSCodeForTicket = createServerFn({ method: \"POST\" })\n  .inputValidator(validator({\n    ticketId: z.string(),\n    projectPath: z.string(),\n    isRalphMode: z.boolean().optional()\n  }))\n  .handler(async ({ data }) => {\n    const { ticketId, projectPath, isRalphMode } = data;\n\n    // 1. Get ticket and project details from database\n    const ticket = await getTicketById(ticketId);\n    const project = await getProjectById(ticket.projectId);\n\n    // 2. Update ticket status to in_progress\n    await updateTicketStatus(ticketId, 'in_progress');\n\n    // 3. Save current-ticket.json state file\n    await saveCurrentTicketState({ ticketId, projectPath });\n\n    // 4. Create context file\n    const contextFile = isRalphMode\n      ? await createRalphContext({ provider: 'vscode', projectPath, ticketId })\n      : await createInteractiveContext({ provider: 'vscode', projectPath, ticketId });\n\n    // 5. Launch VS Code with context file\n    const result = await launchInVSCode(projectPath, contextFile);\n\n    return result;\n  });\n\nexport const launchCursorForTicket = createServerFn({ method: \"POST\" })\n  .inputValidator(validator({\n    ticketId: z.string(),\n    projectPath: z.string(),\n    isRalphMode: z.boolean().optional()\n  }))\n  .handler(async ({ data }) => {\n    // Same pattern as VS Code\n    // ...\n  });\n```\n\n### Step 2: Create helper functions\n\n**Files:** `src/api/context-utils.ts` (new file)\n\nExtract context creation logic:\n\n```typescript\nexport async function createInteractiveContext(params: {\n  provider: AIProvider;\n  projectPath: string;\n  ticketId: string;\n}): Promise<string> {\n  // Create .brain-dump-context.md with ticket details\n}\n\nexport async function createRalphContext(params: {\n  provider: AIProvider;\n  projectPath: string;\n  ticketId: string;\n  prd: EnhancedPRDDocument;\n}): Promise<string> {\n  // Create Ralph mode context with workflow instructions\n}\n```\n\n### Step 3: Update UnifiedLaunchPanel\n\n**Files:** `src/components/tickets/UnifiedLaunchPanel.tsx`\n\nUpdate the component to call the new wrapper functions instead of the raw launch functions.\n\n## Acceptance Criteria\n\n- [ ] VS Code launch updates ticket to in_progress\n- [ ] VS Code launch saves current-ticket.json\n- [ ] VS Code launch creates context file\n- [ ] Same for Cursor\n- [ ] UI refetch shows updated status immediately\n- [ ] Error handling for failed launches\n- [ ] Tests for wrapper functions\n\n## References\n\n- Follow pattern: `launchClaudeInTerminal()` in `src/api/terminal.ts`\n- Follow pattern: `launchOpenCodeInTerminal()` in `src/api/terminal.ts`",
      "acceptanceCriteria": [],
      "priority": "high",
      "tags": ["backend", "provider-system", "vscode", "cursor"],
      "passes": false
    },
    {
      "id": "ticket-37a8bb551ee0",
      "title": "Unified Ralph mode context for all providers",
      "description": "## Overview\n\nRalph mode needs consistent setup across all 4 providers. Currently each provider handles context creation differently, making it hard to ensure Ralph works correctly everywhere.\n\nThis ticket creates a unified `createRalphContext()` function that generates appropriate context files for any provider.\n\n## Types\n\n```typescript\ninterface RalphContextParams {\n  provider: AIProvider; // 'claude-code' | 'vscode' | 'opencode' | 'cursor'\n  projectPath: string;\n  ticketId: string;\n  prd: EnhancedPRDDocument;\n}\n\ninterface RalphContextResult {\n  contextFile: string; // Path to created context file\n  stateFile?: string;  // Path to ralph-state.json (if pre-created)\n  instructions: string; // What the AI should do next\n}\n```\n\n## Implementation Guide\n\n### Step 1: Create unified context generator\n\n**Files:** `src/api/ralph-context.ts` (new file)\n\n```typescript\nexport async function createRalphContext(\n  params: RalphContextParams\n): Promise<RalphContextResult> {\n  const { provider, projectPath, ticketId, prd } = params;\n\n  // For terminal providers (claude-code, opencode):\n  if (provider === 'claude-code' || provider === 'opencode') {\n    // Create .brain-dump-context.md at project root\n    const contextFile = path.join(projectPath, '.brain-dump-context.md');\n    await writeFile(contextFile, generateTerminalContext(ticketId, prd));\n\n    // Don't pre-create state file - MCP tool does this\n    return {\n      contextFile,\n      instructions: 'MCP hooks will create ralph-state.json automatically'\n    };\n  }\n\n  // For editor providers (vscode, cursor):\n  if (provider === 'vscode' || provider === 'cursor') {\n    // Create .claude/ralph-context.md with full instructions\n    const contextFile = path.join(projectPath, '.claude/ralph-context.md');\n    await writeFile(contextFile, generateEditorContext(ticketId, prd));\n\n    return {\n      contextFile,\n      instructions: 'Call create_ralph_session MCP tool to begin Ralph workflow'\n    };\n  }\n}\n```\n\n### Step 2: Create context templates\n\n**Files:** `src/api/ralph-context.ts`\n\nAdd template generators:\n\n```typescript\nfunction generateTerminalContext(ticketId: string, prd: EnhancedPRDDocument): string {\n  return `# Ralph Autonomous Mode\n\nYou are Ralph, an autonomous AI agent working on ticket: ${ticketId}\n\n## 4-Phase Workflow\n\n1. **Analyzing** - Read code, understand requirements\n2. **Implementing** - Write code, make changes\n3. **Testing** - Run tests, verify behavior\n4. **Committing** - Commit changes, update status\n\n## Ticket Details\n\n${prd.overview}\n\n## Implementation Guide\n\n${prd.implementationSteps}\n\n## Acceptance Criteria\n\n${prd.acceptanceCriteria.map(c => `- [ ] ${c}`).join('\\n')}\n\n---\n\nThe hooks will automatically track your state. Begin by analyzing the codebase.`;\n}\n\nfunction generateEditorContext(ticketId: string, prd: EnhancedPRDDocument): string {\n  return `# Ralph Autonomous Mode\n\n**IMPORTANT**: Call \\`create_ralph_session({ ticketId: \"${ticketId}\" })\\` first!\n\nThis starts the Ralph workflow and enables state tracking.\n\n## After Starting Session\n\nFollow the 4-phase workflow:\n1. Analyzing â†’ 2. Implementing â†’ 3. Testing â†’ 4. Committing\n\nUse \\`update_session_state({ sessionId, state })\\` to transition between phases.\n\n## Ticket Details\n\n${prd.overview}\n\n...\n`;\n}\n```\n\n### Step 3: Integration\n\nUpdate all launch functions (`launchClaudeInTerminal`, `launchVSCodeForTicket`, etc.) to use `createRalphContext()` when Ralph mode is enabled.\n\n## Design Decisions\n\n### Why different context files for terminal vs editor?\n\n1. **Terminal providers**: Have hook enforcement, state tracking is automatic\n2. **Editor providers**: No hooks, need explicit instructions to start Ralph session\n\n### Why not pre-create ralph-state.json for editors?\n\n- The MCP tool `create_ralph_session` needs to run in the AI's environment\n- Pre-creating it could cause race conditions or stale state\n- Explicit call ensures proper initialization\n\n## Acceptance Criteria\n\n- [ ] Ralph context works for Claude Code\n- [ ] Ralph context works for OpenCode\n- [ ] Ralph context works for VS Code (with instructions to start session)\n- [ ] Ralph context works for Cursor (with instructions to start session)\n- [ ] Context file includes 4-phase workflow instructions\n- [ ] Editor context prominently explains how to start Ralph session\n- [ ] Tests for context generation\n\n## References\n\n- Existing: `writeVSCodeContext()` in `src/api/vscode.ts`\n- Existing: Terminal context in `src/api/terminal.ts`\n- MCP tool: `create_ralph_session` in `mcp-server/index.js`",
      "acceptanceCriteria": [],
      "priority": "medium",
      "tags": ["backend", "ralph", "provider-system"],
      "passes": false
    },
    {
      "id": "ticket-55963ef10268",
      "title": "End-to-end integration test for unified provider launch",
      "description": "## Overview\n\nWe need comprehensive integration tests that verify the entire unified launch flow works correctly for all providers. This ensures nothing breaks as we add new providers or modify the launch logic.\n\n## Test Scenarios\n\n### 1. Claude Code Interactive Launch\n- User selects Claude Code\n- Clicks Launch\n- Terminal opens with correct context\n- Ticket status updates to in_progress\n\n### 2. Claude Code Ralph Launch\n- User toggles Ralph mode\n- Selects Claude Code\n- Clicks Launch\n- Terminal opens with Ralph context\n- Ticket status updates to in_progress\n\n### 3. VS Code Interactive Launch\n- User selects VS Code\n- Clicks Launch\n- VS Code opens with project\n- Context file created\n- Ticket status updates\n\n### 4. VS Code Ralph Launch\n- User toggles Ralph mode\n- Selects VS Code\n- Clicks Launch\n- VS Code opens with Ralph context\n- Instructions to call create_ralph_session\n\n### 5. OpenCode Launches\n- Same as Claude Code (terminal provider)\n\n### 6. Cursor Launches\n- Same as VS Code (editor provider)\n\n### 7. Uninstalled Provider\n- Provider not installed\n- Button is disabled\n- Tooltip explains why\n\n### 8. Remember Choice\n- User checks \"Remember\"\n- Makes selection\n- Next time, default is pre-selected\n\n## Implementation Guide\n\n### Step 1: Unit tests for components\n\n**Files:** `src/components/tickets/UnifiedLaunchPanel.test.tsx`\n\n```typescript\ndescribe('UnifiedLaunchPanel', () => {\n  it('renders all 4 provider options', () => {\n    // Test UI rendering\n  });\n\n  it('disables uninstalled providers', () => {\n    // Mock detection to return false\n    // Verify button is disabled\n  });\n\n  it('shows Ralph toggle', () => {\n    // Verify checkbox exists\n  });\n\n  it('remembers user choice', () => {\n    // Mock localStorage\n    // Verify persistence\n  });\n});\n```\n\n### Step 2: Integration tests for API\n\n**Files:** `src/api/terminal.test.ts`\n\n```typescript\ndescribe('Provider Launch API', () => {\n  it('updates ticket status when launching Claude Code', async () => {\n    // Create test ticket\n    // Call launchClaudeInTerminal\n    // Verify status changed to in_progress\n  });\n\n  it('creates context file for VS Code launch', async () => {\n    // Call launchVSCodeForTicket\n    // Verify .brain-dump-context.md exists\n    // Verify content is correct\n  });\n\n  it('creates Ralph context when Ralph mode enabled', async () => {\n    // Call with isRalphMode: true\n    // Verify Ralph-specific context\n  });\n});\n```\n\n### Step 3: E2E tests\n\n**Files:** `e2e/unified-launch.spec.ts`\n\n```typescript\ntest('full launch flow for Claude Code', async ({ page }) => {\n  // Navigate to ticket detail\n  // Click launch panel\n  // Select Claude Code\n  // Click launch\n  // Verify ticket status updated (check UI)\n  // Verify terminal command was executed (mock)\n});\n\ntest('Ralph mode creates appropriate context', async ({ page }) => {\n  // Toggle Ralph mode\n  // Launch provider\n  // Verify context file contains Ralph instructions\n});\n```\n\n## Acceptance Criteria\n\n- [ ] All 8 launch scenarios have tests\n- [ ] Tests verify ticket status updates\n- [ ] Tests verify context file creation\n- [ ] E2E test simulates full user flow\n- [ ] Tests handle provider detection mocking\n- [ ] Tests verify error handling\n- [ ] All tests pass with `pnpm test` and `pnpm test:e2e`\n\n## References\n\n- Existing tests: `src/components/tickets/TicketDetail.test.tsx`\n- Testing patterns: Follow Kent C. Dodds philosophy (see CLAUDE.md)\n- E2E patterns: `e2e/ticket-creation.spec.ts`",
      "acceptanceCriteria": [],
      "priority": "medium",
      "tags": ["testing", "provider-system", "e2e"],
      "passes": false
    }
  ],
  "generatedAt": "2026-01-28T20:22:29.137Z"
}

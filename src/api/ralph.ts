import { createServerFn } from "@tanstack/react-start";
import { db } from "../lib/db";
import { tickets, epics, projects } from "../lib/schema";
import { eq, and, inArray } from "drizzle-orm";
import { safeJsonParse } from "../lib/utils";

interface PRDUserStory {
  id: string;
  title: string;
  description: string | null;
  acceptanceCriteria: string[];
  priority: string | null;
  tags: string[];
  passes: boolean;
}

interface PRDDocument {
  projectName: string;
  projectPath: string;
  epicTitle?: string;
  epicDescription?: string;
  testingRequirements: string[];
  userStories: PRDUserStory[];
  generatedAt: string;
}

// Generate PRD JSON from tickets
function generatePRD(
  projectName: string,
  projectPath: string,
  ticketList: typeof tickets.$inferSelect[],
  epicTitle?: string
): PRDDocument {
  const userStories: PRDUserStory[] = ticketList.map((ticket) => {
    const tags = safeJsonParse<string[]>(ticket.tags, []);

    // Parse subtasks as acceptance criteria if they exist
    let acceptanceCriteria: string[] = [];
    const subtasks = safeJsonParse<{ text: string }[]>(ticket.subtasks, []);
    if (subtasks.length > 0) {
      acceptanceCriteria = subtasks.map((st) => st.text || String(st));
    }

    // If no subtasks, create basic acceptance criteria from description
    if (acceptanceCriteria.length === 0 && ticket.description) {
      acceptanceCriteria = ["Implement as described", "Verify functionality works as expected"];
    }

    return {
      id: ticket.id,
      title: ticket.title,
      description: ticket.description,
      acceptanceCriteria,
      priority: ticket.priority,
      tags,
      passes: ticket.status === "done",
    };
  });

  const result: PRDDocument = {
    projectName,
    projectPath,
    testingRequirements: [
      "Tests must validate user-facing behavior, not implementation details",
      "Focus on what users actually do - integration tests over unit tests",
      "Don't mock excessively - test real behavior where possible",
      "Coverage metrics are meaningless - user flow coverage is everything",
    ],
    userStories,
    generatedAt: new Date().toISOString(),
  };
  if (epicTitle !== undefined) {
    result.epicTitle = epicTitle;
  }
  return result;
}

// Lean Ralph prompt - MCP tools handle workflow, Ralph focuses on implementation
function getRalphPrompt(): string {
  return `You are Ralph, an autonomous coding agent. Focus on implementation - MCP tools handle workflow.

## Your Task
1. Read plans/prd.json to see incomplete tickets (passes: false)
2. Read plans/progress.txt for context from previous work
3. Strategically pick ONE ticket (consider priority, dependencies, foundation work)
4. Call start_ticket_work(ticketId) - this creates branch and posts progress
5. Implement the feature:
   - Write the code
   - Run tests: pnpm test (or npm test)
   - Verify acceptance criteria
6. Git commit: git commit -m "feat(<ticket-id>): <description>"
7. Call complete_ticket_work(ticketId, "summary of changes") - this updates PRD and posts summary
8. If all tickets complete, output: PRD_COMPLETE

## Rules
- ONE ticket per iteration
- Run tests before completing
- Keep changes minimal and focused
- If stuck, note in progress.txt and move on`;
}

// Generate VS Code context file for Ralph mode
// This creates a markdown file that Claude in VS Code can read
function generateVSCodeContext(prd: PRDDocument): string {
  const incompleteTickets = prd.userStories.filter((story) => !story.passes);
  const completedTickets = prd.userStories.filter((story) => story.passes);

  const ticketList = incompleteTickets
    .map((ticket) => {
      const priority = ticket.priority ? ` (${ticket.priority})` : "";
      return `- **${ticket.title}**${priority}\n  ID: \`${ticket.id}\``;
    })
    .join("\n");

  const epicHeader = prd.epicTitle ? `\n**Epic:** ${prd.epicTitle}` : "";

  return `# Ralph Context - ${prd.projectName}

> This file was auto-generated by Brain Dump for Ralph mode in VS Code.
> Read this file to understand the current task context.
${epicHeader}
**Generated:** ${new Date().toISOString()}

---

## Your Task

You are Ralph, an autonomous coding agent. Follow these steps:

1. **Read PRD** - Check \`plans/prd.json\` for incomplete tickets (\`passes: false\`)
2. **Read Progress** - Check \`plans/progress.txt\` for context from previous work
3. **Pick ONE ticket** - Strategically choose based on priority, dependencies, foundation work
4. **Start work** - Call \`start_ticket_work(ticketId)\` via MCP
5. **Implement** - Write code, run tests (\`pnpm test\`), verify acceptance criteria
6. **Commit** - \`git commit -m "feat(<ticket-id>): <description>"\`
7. **Complete** - Call \`complete_ticket_work(ticketId, "summary")\` via MCP
8. **Repeat** or output \`PRD_COMPLETE\` if all done

---

## Current Tickets

**Incomplete (${incompleteTickets.length}):**
${ticketList || "_No incomplete tickets_"}

**Completed (${completedTickets.length}):** ${completedTickets.map((t) => t.title).join(", ") || "_None_"}

---

## Rules

- ONE ticket per iteration
- Run tests before completing
- Keep changes minimal and focused
- If stuck, note in \`plans/progress.txt\` and move on

---

## MCP Tools Available

- \`start_ticket_work(ticketId)\` - Creates branch, posts "Starting work" comment
- \`complete_ticket_work(ticketId, summary)\` - Updates status, posts summary, suggests next ticket
- \`add_ticket_comment(ticketId, content, author, type)\` - Add work notes

---

## Testing Requirements

${prd.testingRequirements.map((req) => `- ${req}`).join("\n")}
`;
}

// Write VS Code context file to project
async function writeVSCodeContext(
  projectPath: string,
  content: string
): Promise<{ success: true; path: string } | { success: false; message: string }> {
  const { writeFileSync, mkdirSync } = await import("fs");
  const { join } = await import("path");

  const claudeDir = join(projectPath, ".claude");
  const contextPath = join(claudeDir, "ralph-context.md");

  try {
    mkdirSync(claudeDir, { recursive: true });
    writeFileSync(contextPath, content, "utf-8");
    return { success: true, path: contextPath };
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    console.error(`[brain-dump] Failed to write VS Code context file to ${contextPath}:`, error);
    return {
      success: false,
      message: `Failed to create Ralph context file in ${claudeDir}: ${message}. Check write permissions and disk space.`,
    };
  }
}

// Generate the Ralph bash script (unified for both native and Docker)
function generateRalphScript(
  projectPath: string,
  maxIterations: number = 10,
  useSandbox: boolean = false
): string {
  const imageName = "brain-dump-ralph-sandbox:latest";
  const sandboxHeader = useSandbox ? " (Docker Sandbox)" : "";
  const containerInfo = useSandbox ? `echo -e "\\033[1;33mğŸ³ Container:\\033[0m ${imageName}"` : "";

  // Docker image check (only for sandbox mode)
  const dockerImageCheck = useSandbox
    ? `
# Check if Docker image exists
if ! docker image inspect "${imageName}" > /dev/null 2>&1; then
  echo -e "\\033[0;31mâŒ Docker image not found: ${imageName}\\033[0m"
  echo "Please build the sandbox image first in Brain Dump settings."
  exit 1
fi
`
    : "";

  // Different prompt file location and Claude invocation for sandbox vs native
  // For native mode, use mktemp -t for cross-platform compatibility (works on both macOS and Linux)
  // Add error handling to fail fast if temp file creation fails
  const promptFileSetup = useSandbox
    ? `PROMPT_FILE="$PROJECT_PATH/.ralph-prompt.md"`
    : `PROMPT_FILE=$(mktemp -t ralph-prompt) || { echo -e "\\033[0;31mâŒ Failed to create temp file\\033[0m"; exit 1; }`;

  const claudeInvocation = useSandbox
    ? `  # Run Claude in Docker container
  # Claude Code auth is passed via mounted ~/.config/claude-code (uses your existing subscription)
  docker run --rm -it \\
    --name "ralph-\${SESSION_ID}" \\
    --network ralph-net \\
    -v "$PROJECT_PATH:/workspace" \\
    -v "\\$HOME/.config/claude-code:/home/ralph/.config/claude-code:ro" \\
    -v "\\$HOME/.gitconfig:/home/ralph/.gitconfig:ro" \\
    -v "\\$HOME/.config/gh:/home/ralph/.config/gh:ro" \\
    -w /workspace \\
    "${imageName}" \\
    claude --dangerously-skip-permissions /workspace/.ralph-prompt.md`
    : `  # Run Claude directly - no output capture so it streams naturally
  claude --dangerously-skip-permissions "$PROMPT_FILE"`;

  const iterationLabel = useSandbox ? "(Docker)" : "";
  const endMessage = useSandbox ? "" : `echo "Run again with: $0 <max_iterations>"`;

  return `#!/bin/bash
set -e

MAX_ITERATIONS=\${1:-${maxIterations}}
PROJECT_PATH="${projectPath}"
PRD_FILE="$PROJECT_PATH/plans/prd.json"
PROGRESS_FILE="$PROJECT_PATH/plans/progress.txt"
SESSION_ID="$(date +%s)-$$"

cd "$PROJECT_PATH"
${dockerImageCheck}
# Ensure plans directory exists
mkdir -p "$PROJECT_PATH/plans"

# Initialize progress file if it doesn't exist
if [ ! -f "$PROGRESS_FILE" ]; then
  echo "# Ralph Progress Log" > "$PROGRESS_FILE"
  echo "# Use this to leave notes for the next iteration" >> "$PROGRESS_FILE"
  echo "" >> "$PROGRESS_FILE"
fi

echo ""
echo -e "\\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
echo -e "\\033[0;32mğŸ§  Brain Dump - Ralph Mode${sandboxHeader}\\033[0m"
echo -e "\\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
echo -e "\\033[1;33mğŸ“ Project:\\033[0m $PROJECT_PATH"
${containerInfo}
echo -e "\\033[1;33mğŸ“‹ PRD:\\033[0m $PRD_FILE"
echo -e "\\033[1;33mğŸ”„ Max Iterations:\\033[0m $MAX_ITERATIONS"
echo -e "\\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
echo ""

for i in $(seq 1 $MAX_ITERATIONS); do
  echo ""
  echo -e "\\033[0;35mâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\033[0m"
  echo -e "\\033[0;35m  Ralph Iteration $i of $MAX_ITERATIONS ${iterationLabel}\\033[0m"
  echo -e "\\033[0;35m  Started at $(date '+%Y-%m-%d %H:%M:%S')\\033[0m"
  echo -e "\\033[0;35mâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\033[0m"
  echo ""

  # Create prompt file for this iteration
  ${promptFileSetup}
  cat > "$PROMPT_FILE" << 'RALPH_PROMPT_EOF'
${getRalphPrompt()}
RALPH_PROMPT_EOF

  echo -e "\\033[0;33mâ³ Starting Claude${useSandbox ? " in Docker sandbox" : " (autonomous mode)"}...\\033[0m"
  echo ""

${claudeInvocation}
  CLAUDE_EXIT_CODE=$?

  rm -f "$PROMPT_FILE"

  echo ""
  echo -e "\\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\033[0m"
  echo -e "\\033[0;36m  Iteration $i complete at $(date '+%H:%M:%S')\\033[0m"
  echo -e "\\033[0;36m  Exit code: $CLAUDE_EXIT_CODE\\033[0m"
  echo -e "\\033[0;36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\033[0m"

  # Check if all tasks in PRD are complete (all have passes:true)
  if [ -f "$PRD_FILE" ]; then
    INCOMPLETE=$(grep -c '"passes": false' "$PRD_FILE" 2>/dev/null || echo "0")
    TOTAL=$(grep -c '"passes":' "$PRD_FILE" 2>/dev/null || echo "0")
    COMPLETE=$((TOTAL - INCOMPLETE))

    echo ""
    echo -e "\\033[0;36mğŸ“Š Progress: $COMPLETE/$TOTAL tasks complete\\033[0m"

    if [ "$INCOMPLETE" = "0" ] && [ "$TOTAL" != "0" ]; then
      echo ""
      echo -e "\\033[0;32mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
      echo -e "\\033[0;32mâœ… All tasks complete! Ralph is done.\\033[0m"
      echo -e "\\033[0;32mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
      exit 0
    fi
  fi

  echo ""
  echo -e "\\033[0;33mğŸ”„ Moving to next iteration...\\033[0m"
  sleep 2
done

echo ""
echo -e "\\033[0;33mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
echo -e "\\033[0;33mâš ï¸  Max iterations reached. Some tasks may remain.\\033[0m"
echo -e "\\033[0;33mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m"
echo ""
${endMessage}
exec bash
`;
}

// Ensure Docker network exists for container networking
async function ensureDockerNetwork(
  networkName: string
): Promise<{ success: true } | { success: false; message: string }> {
  const { exec } = await import("child_process");
  const { promisify } = await import("util");
  const execAsync = promisify(exec);

  try {
    // Check if network already exists
    await execAsync(`docker network inspect ${networkName}`);
    console.log(`[brain-dump] Docker network "${networkName}" already exists`);
    return { success: true };
  } catch {
    // Network doesn't exist, create it
    try {
      await execAsync(`docker network create ${networkName}`);
      console.log(`[brain-dump] Created Docker network "${networkName}"`);
      return { success: true };
    } catch (createError) {
      // Race condition: another process may have created it between our check and create
      // Verify by checking again
      try {
        await execAsync(`docker network inspect ${networkName}`);
        console.log(`[brain-dump] Docker network "${networkName}" exists (created by another process)`);
        return { success: true };
      } catch {
        return {
          success: false,
          message: `Failed to create Docker network "${networkName}": ${createError instanceof Error ? createError.message : "Unknown error"}`,
        };
      }
    }
  }
}

// Validate Docker setup for sandbox mode
async function validateDockerSetup(): Promise<{ success: true } | { success: false; message: string }> {
  const { exec } = await import("child_process");
  const { promisify } = await import("util");
  const { existsSync } = await import("fs");
  const { join } = await import("path");

  const execAsync = promisify(exec);

  // Check if Docker is running
  try {
    await execAsync("docker info");
  } catch {
    return {
      success: false,
      message: "Docker is not running. Please start Docker Desktop or run 'sudo systemctl start docker'",
    };
  }

  // Ensure ralph-net network exists for container networking
  const networkResult = await ensureDockerNetwork("ralph-net");
  if (!networkResult.success) {
    return networkResult;
  }

  // Check if image exists, build if not
  try {
    await execAsync("docker image inspect brain-dump-ralph-sandbox:latest");
  } catch {
    // Image doesn't exist, try to build it
    console.log("[brain-dump] Building sandbox image...");
    const dockerfilePath = join(process.cwd(), "docker", "ralph-sandbox.Dockerfile");
    const contextPath = join(process.cwd(), "docker");

    if (!existsSync(dockerfilePath)) {
      return {
        success: false,
        message: "Dockerfile not found. Please ensure brain-dump is installed correctly.",
      };
    }

    try {
      await execAsync(
        `docker build -t brain-dump-ralph-sandbox:latest -f "${dockerfilePath}" "${contextPath}"`,
        { timeout: 300000 }
      );
      console.log("[brain-dump] Sandbox image built successfully");
    } catch (buildError) {
      return {
        success: false,
        message: `Failed to build sandbox image: ${buildError instanceof Error ? buildError.message : "Unknown error"}`,
      };
    }
  }

  return { success: true };
}

// Check if VS Code CLI is available and get the path
async function findVSCodeCli(): Promise<string | null> {
  const { execSync } = await import("child_process");
  const { existsSync } = await import("fs");

  // First check if 'code' is in PATH
  try {
    execSync("which code", { stdio: "pipe" });
    return "code";
  } catch {
    // Not in PATH, check common macOS locations
  }

  // macOS: Check the full path to VS Code CLI
  const macOSPaths = [
    "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code",
    "/usr/local/bin/code",
    `${process.env.HOME}/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code`,
  ];

  for (const codePath of macOSPaths) {
    if (existsSync(codePath)) {
      return codePath;
    }
  }

  return null;
}

// Launch VS Code with project context
async function launchInVSCode(
  projectPath: string,
  contextFilePath?: string
): Promise<{ success: true } | { success: false; message: string }> {
  const { exec } = await import("child_process");
  const { existsSync } = await import("fs");

  // Verify project path exists
  if (!existsSync(projectPath)) {
    return {
      success: false,
      message: `Project directory not found: ${projectPath}`,
    };
  }

  // Find VS Code CLI
  const codeCli = await findVSCodeCli();
  if (!codeCli) {
    return {
      success: false,
      message:
        "VS Code CLI not found. Please install VS Code and ensure the 'code' command is available. " +
        "In VS Code, open Command Palette (Cmd+Shift+P) and run 'Shell Command: Install code command in PATH'.",
    };
  }

  // Build the command
  // Note: projectPath and contextFilePath come from the database (trusted internal values)
  // We quote paths to handle spaces but these are not arbitrary user input
  // Use -n flag to open in new window, -g to not focus a specific file
  let command = `"${codeCli}" -n "${projectPath}"`;

  // If context file provided, open it as well
  if (contextFilePath && existsSync(contextFilePath)) {
    command += ` -g "${contextFilePath}"`;
  }

  try {
    exec(command, (error) => {
      if (error) {
        console.error("VS Code launch error:", error);
      }
    });

    return { success: true };
  } catch (error) {
    return {
      success: false,
      message: `Failed to launch VS Code: ${error instanceof Error ? error.message : "Unknown error"}`,
    };
  }
}

// Shared launch logic for terminal
async function launchInTerminal(
  projectPath: string,
  scriptPath: string,
  preferredTerminal?: string | null
): Promise<{ success: true; terminal: string } | { success: false; message: string }> {
  const { exec } = await import("child_process");
  const { detectTerminal, buildTerminalCommand } = await import("./terminal-utils");

  let terminal = preferredTerminal;
  if (!terminal) {
    terminal = await detectTerminal();
  }

  if (!terminal) {
    return {
      success: false,
      message: "No terminal emulator found. Please install one or set a preference.",
    };
  }

  const terminalCommand = buildTerminalCommand(terminal, projectPath, scriptPath);

  try {
    exec(terminalCommand, (error) => {
      if (error) {
        console.error("Terminal launch error:", error);
      }
    });

    return { success: true, terminal };
  } catch (error) {
    return {
      success: false,
      message: `Failed to launch terminal: ${error instanceof Error ? error.message : "Unknown error"}`,
    };
  }
}

// Launch Ralph for a single ticket
export const launchRalphForTicket = createServerFn({ method: "POST" })
  .inputValidator(
    (data: { ticketId: string; maxIterations?: number; preferredTerminal?: string | null; useSandbox?: boolean }) => data
  )
  .handler(async ({ data }) => {
    const { ticketId, maxIterations = 5, preferredTerminal, useSandbox = false } = data;
    const { writeFileSync, mkdirSync, existsSync, chmodSync } = await import("fs");
    const { join } = await import("path");
    const { homedir } = await import("os");
    const { randomUUID } = await import("crypto");

    // Get the ticket with its project
    const ticket = db
      .select()
      .from(tickets)
      .where(eq(tickets.id, ticketId))
      .get();

    if (!ticket) {
      return { success: false, message: "Ticket not found" };
    }

    const project = db
      .select()
      .from(projects)
      .where(eq(projects.id, ticket.projectId))
      .get();

    if (!project) {
      return { success: false, message: "Project not found" };
    }

    if (!existsSync(project.path)) {
      return { success: false, message: `Project directory not found: ${project.path}` };
    }

    // If sandbox mode, validate Docker setup
    if (useSandbox) {
      const dockerResult = await validateDockerSetup();
      if (!dockerResult.success) {
        return dockerResult;
      }
    }

    // Create plans directory in project
    const plansDir = join(project.path, "plans");
    mkdirSync(plansDir, { recursive: true });

    // Generate PRD with just this ticket
    const prd = generatePRD(project.name, project.path, [ticket]);
    const prdPath = join(plansDir, "prd.json");
    writeFileSync(prdPath, JSON.stringify(prd, null, 2));

    // Generate Ralph script
    const ralphScript = generateRalphScript(project.path, maxIterations, useSandbox);
    const scriptDir = join(homedir(), ".brain-dump", "scripts");
    mkdirSync(scriptDir, { recursive: true });
    const scriptPath = join(scriptDir, `ralph-${useSandbox ? "docker-" : ""}${randomUUID()}.sh`);
    writeFileSync(scriptPath, ralphScript, { mode: 0o700 });
    chmodSync(scriptPath, 0o700);

    // Update ticket status to in_progress
    db.update(tickets)
      .set({ status: "in_progress" })
      .where(eq(tickets.id, ticketId))
      .run();

    // Branch based on workingMethod setting
    const workingMethod = project.workingMethod || "auto";
    console.log(`[brain-dump] Ralph ticket launch: workingMethod="${workingMethod}" for project "${project.name}"`);

    if (workingMethod === "vscode") {
      // VS Code path: generate context file and launch VS Code
      console.log(`[brain-dump] Using VS Code launch path for single ticket`);

      // Generate the context file for Claude in VS Code (single ticket PRD)
      const contextContent = generateVSCodeContext(prd);
      const contextResult = await writeVSCodeContext(project.path, contextContent);

      if (!contextResult.success) {
        // Rollback ticket status since launch failed
        db.update(tickets)
          .set({ status: ticket.status })
          .where(eq(tickets.id, ticketId))
          .run();
        return contextResult;
      }

      console.log(`[brain-dump] Created Ralph context file: ${contextResult.path}`);

      const launchResult = await launchInVSCode(project.path, contextResult.path);

      if (!launchResult.success) {
        // Rollback ticket status since launch failed
        db.update(tickets)
          .set({ status: ticket.status })
          .where(eq(tickets.id, ticketId))
          .run();
        return launchResult;
      }

      return {
        success: true,
        message: `Opened VS Code with Ralph context for ticket "${ticket.title}". Check .claude/ralph-context.md for instructions.`,
        launchMethod: "vscode" as const,
        contextFile: contextResult.path,
      };
    }

    // Terminal path (claude-code or auto): launch in terminal emulator
    console.log(`[brain-dump] Using terminal launch path for single ticket`);
    const launchResult = await launchInTerminal(project.path, scriptPath, preferredTerminal);

    if (!launchResult.success) {
      return launchResult;
    }

    return {
      success: true,
      message: `Launched Ralph in ${launchResult.terminal}`,
      terminalUsed: launchResult.terminal,
      launchMethod: "terminal" as const,
    };
  });

// Launch Ralph for an entire epic
export const launchRalphForEpic = createServerFn({ method: "POST" })
  .inputValidator(
    (data: { epicId: string; maxIterations?: number; preferredTerminal?: string | null; useSandbox?: boolean }) => data
  )
  .handler(async ({ data }) => {
    const { epicId, maxIterations = 20, preferredTerminal, useSandbox = false } = data;
    const { writeFileSync, mkdirSync, existsSync, chmodSync } = await import("fs");
    const { join } = await import("path");
    const { homedir } = await import("os");
    const { randomUUID } = await import("crypto");

    // Get the epic
    const epic = db
      .select()
      .from(epics)
      .where(eq(epics.id, epicId))
      .get();

    if (!epic) {
      return { success: false, message: "Epic not found" };
    }

    const project = db
      .select()
      .from(projects)
      .where(eq(projects.id, epic.projectId))
      .get();

    if (!project) {
      return { success: false, message: "Project not found" };
    }

    if (!existsSync(project.path)) {
      return { success: false, message: `Project directory not found: ${project.path}` };
    }

    // If sandbox mode, validate Docker setup
    if (useSandbox) {
      const dockerResult = await validateDockerSetup();
      if (!dockerResult.success) {
        return dockerResult;
      }
    }

    // Get all non-done tickets for this epic
    const epicTickets = db
      .select()
      .from(tickets)
      .where(
        and(
          eq(tickets.epicId, epicId),
          inArray(tickets.status, ["backlog", "ready", "in_progress", "review"])
        )
      )
      .all();

    if (epicTickets.length === 0) {
      return { success: false, message: "No pending tickets in this epic" };
    }

    // Create plans directory in project
    const plansDir = join(project.path, "plans");
    mkdirSync(plansDir, { recursive: true });

    // Generate PRD with all epic tickets
    const prd = generatePRD(project.name, project.path, epicTickets, epic.title);
    const prdPath = join(plansDir, "prd.json");
    writeFileSync(prdPath, JSON.stringify(prd, null, 2));

    // Generate Ralph script
    const ralphScript = generateRalphScript(project.path, maxIterations, useSandbox);
    const scriptDir = join(homedir(), ".brain-dump", "scripts");
    mkdirSync(scriptDir, { recursive: true });
    const scriptPath = join(scriptDir, `ralph-epic-${useSandbox ? "docker-" : ""}${randomUUID()}.sh`);
    writeFileSync(scriptPath, ralphScript, { mode: 0o700 });
    chmodSync(scriptPath, 0o700);

    // Update all tickets to in_progress
    for (const ticket of epicTickets) {
      if (ticket.status === "backlog" || ticket.status === "ready") {
        db.update(tickets)
          .set({ status: "in_progress" })
          .where(eq(tickets.id, ticket.id))
          .run();
      }
    }

    // Branch based on workingMethod setting
    const workingMethod = project.workingMethod || "auto";
    console.log(`[brain-dump] Ralph launch: workingMethod="${workingMethod}" for project "${project.name}"`);

    if (workingMethod === "vscode") {
      // VS Code path: generate context file and launch VS Code
      console.log(`[brain-dump] Using VS Code launch path`);

      // Generate the context file for Claude in VS Code
      const contextContent = generateVSCodeContext(prd);
      const contextResult = await writeVSCodeContext(project.path, contextContent);

      if (!contextResult.success) {
        // Rollback ticket statuses since launch failed
        for (const ticket of epicTickets) {
          db.update(tickets)
            .set({ status: ticket.status })
            .where(eq(tickets.id, ticket.id))
            .run();
        }
        return contextResult;
      }

      console.log(`[brain-dump] Created Ralph context file: ${contextResult.path}`);

      const launchResult = await launchInVSCode(project.path, contextResult.path);

      if (!launchResult.success) {
        // Rollback ticket statuses since launch failed
        for (const ticket of epicTickets) {
          db.update(tickets)
            .set({ status: ticket.status })
            .where(eq(tickets.id, ticket.id))
            .run();
        }
        return launchResult;
      }

      return {
        success: true,
        message: `Opened VS Code with Ralph context for ${epicTickets.length} tickets. Check .claude/ralph-context.md for instructions.`,
        launchMethod: "vscode" as const,
        contextFile: contextResult.path,
        ticketCount: epicTickets.length,
      };
    }

    // Terminal path (claude-code or auto): launch in terminal emulator
    console.log(`[brain-dump] Using terminal launch path`);
    const launchResult = await launchInTerminal(project.path, scriptPath, preferredTerminal);

    if (!launchResult.success) {
      return launchResult;
    }

    return {
      success: true,
      message: `Launched Ralph for ${epicTickets.length} tickets in ${launchResult.terminal}`,
      terminalUsed: launchResult.terminal,
      launchMethod: "terminal" as const,
      ticketCount: epicTickets.length,
    };
  });

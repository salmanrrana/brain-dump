/**
 * Tests for VS Code Working Method Flow
 *
 * Following Kent C. Dodds' testing philosophy:
 * - Test user-facing behavior, not implementation details
 * - Focus on what users actually experience
 * - Don't mock excessively - test real behavior where possible
 *
 * Users experience:
 * 1. The context file content (.claude/ralph-context.md)
 * 2. The PRD JSON structure (what Ralph uses to pick tasks)
 */

import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdirSync, writeFileSync, rmSync, existsSync, readFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { randomUUID } from "crypto";

// We'll test the exported functions by importing the module
// For generateVSCodeContext and generatePRD, we need to extract them or test via the API

// Since the functions are not exported directly, we'll test the observable outputs
// by simulating what the API does and checking the results

interface PRDUserStory {
  id: string;
  title: string;
  description: string | null;
  acceptanceCriteria: string[];
  priority: string | null;
  tags: string[];
  passes: boolean;
}

interface PRDDocument {
  projectName: string;
  projectPath: string;
  epicTitle?: string;
  testingRequirements: string[];
  userStories: PRDUserStory[];
  generatedAt: string;
}

// Helper to create a mock PRD (simulates what generatePRD produces)
function createMockPRD(options: {
  projectName: string;
  projectPath: string;
  epicTitle?: string;
  tickets: Array<{
    id: string;
    title: string;
    description?: string;
    priority?: string;
    status: string;
    tags?: string[];
  }>;
}): PRDDocument {
  const userStories: PRDUserStory[] = options.tickets.map((ticket) => ({
    id: ticket.id,
    title: ticket.title,
    description: ticket.description || null,
    acceptanceCriteria: ticket.description
      ? ["Implement as described", "Verify functionality works as expected"]
      : [],
    priority: ticket.priority || null,
    tags: ticket.tags || [],
    passes: ticket.status === "done",
  }));

  const result: PRDDocument = {
    projectName: options.projectName,
    projectPath: options.projectPath,
    testingRequirements: [
      "Tests must validate user-facing behavior, not implementation details",
      "Focus on what users actually do - integration tests over unit tests",
      "Don't mock excessively - test real behavior where possible",
      "Coverage metrics are meaningless - user flow coverage is everything",
    ],
    userStories,
    generatedAt: new Date().toISOString(),
  };

  if (options.epicTitle) {
    result.epicTitle = options.epicTitle;
  }

  return result;
}

// Helper to generate VS Code context (mirrors the actual function behavior)
function generateVSCodeContext(prd: PRDDocument): string {
  const incompleteTickets = prd.userStories.filter((story) => !story.passes);
  const completedTickets = prd.userStories.filter((story) => story.passes);

  const ticketList = incompleteTickets
    .map((ticket) => {
      const priority = ticket.priority ? ` (${ticket.priority})` : "";
      return `- **${ticket.title}**${priority}\n  ID: \`${ticket.id}\``;
    })
    .join("\n");

  const epicHeader = prd.epicTitle ? `\n**Epic:** ${prd.epicTitle}` : "";

  return `# Ralph Context - ${prd.projectName}

> This file was auto-generated by Brain Dump for Ralph mode in VS Code.
> Read this file to understand the current task context.
${epicHeader}
**Generated:** ${new Date().toISOString()}

---

## Your Task

You are Ralph, an autonomous coding agent. Follow these steps:

1. **Read PRD** - Check \`plans/prd.json\` for incomplete tickets (\`passes: false\`)
2. **Read Progress** - Check \`plans/progress.txt\` for context from previous work
3. **Pick ONE ticket** - Strategically choose based on priority, dependencies, foundation work
4. **Start work** - Call \`start_ticket_work(ticketId)\` via MCP
5. **Implement** - Write code, run tests (\`pnpm test\`), verify acceptance criteria
6. **Commit** - \`git commit -m "feat(<ticket-id>): <description>"\`
7. **Complete** - Call \`complete_ticket_work(ticketId, "summary")\` via MCP
8. **Repeat** or output \`PRD_COMPLETE\` if all done

---

## Current Tickets

**Incomplete (${incompleteTickets.length}):**
${ticketList || "_No incomplete tickets_"}

**Completed (${completedTickets.length}):** ${completedTickets.map((t) => t.title).join(", ") || "_None_"}

---

## Rules

- ONE ticket per iteration
- Run tests before completing
- Keep changes minimal and focused
- If stuck, note in \`plans/progress.txt\` and move on

---

## MCP Tools Available

- \`start_ticket_work(ticketId)\` - Creates branch, posts "Starting work" comment
- \`complete_ticket_work(ticketId, summary)\` - Updates status, posts summary, suggests next ticket
- \`add_ticket_comment(ticketId, content, author, type)\` - Add work notes

---

## Testing Requirements

${prd.testingRequirements.map((req) => `- ${req}`).join("\n")}
`;
}

describe("VS Code Working Method Flow", () => {
  let testDir: string;

  beforeEach(() => {
    // Create a unique temp directory for each test
    testDir = join(tmpdir(), `ralph-test-${randomUUID()}`);
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  // ===========================================================================
  // PRD GENERATION - User sees this in plans/prd.json
  // ===========================================================================

  describe("PRD Generation (what Ralph reads)", () => {
    it("should mark tickets as passes:false when not done", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        tickets: [
          { id: "ticket-1", title: "Add login form", status: "backlog" },
          { id: "ticket-2", title: "Add logout button", status: "in_progress" },
        ],
      });

      // User expectation: Ralph sees incomplete tickets
      expect(prd.userStories).toHaveLength(2);
      const [story1, story2] = prd.userStories;
      expect(story1?.passes).toBe(false);
      expect(story2?.passes).toBe(false);
    });

    it("should mark tickets as passes:true when done", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        tickets: [
          { id: "ticket-1", title: "Add login form", status: "done" },
          { id: "ticket-2", title: "Add logout button", status: "backlog" },
        ],
      });

      // User expectation: Ralph sees which tasks are complete
      expect(prd.userStories).toHaveLength(2);
      const [doneStory, pendingStory] = prd.userStories;
      expect(doneStory?.passes).toBe(true);
      expect(pendingStory?.passes).toBe(false);
    });

    it("should include epic title when provided", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        epicTitle: "Authentication Epic",
        tickets: [{ id: "ticket-1", title: "Add login", status: "backlog" }],
      });

      // User expectation: Epic context is preserved
      expect(prd.epicTitle).toBe("Authentication Epic");
    });

    it("should include testing requirements for Ralph to follow", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        tickets: [{ id: "ticket-1", title: "Test", status: "backlog" }],
      });

      // User expectation: Testing philosophy is embedded
      expect(prd.testingRequirements).toContain(
        "Tests must validate user-facing behavior, not implementation details"
      );
    });

    it("should preserve ticket priority for Ralph to prioritize", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        tickets: [
          { id: "ticket-1", title: "Critical fix", status: "backlog", priority: "high" },
          { id: "ticket-2", title: "Nice to have", status: "backlog", priority: "low" },
        ],
      });

      // User expectation: Priority helps Ralph pick the right task
      expect(prd.userStories).toHaveLength(2);
      const [highPriorityStory, lowPriorityStory] = prd.userStories;
      expect(highPriorityStory?.priority).toBe("high");
      expect(lowPriorityStory?.priority).toBe("low");
    });
  });

  // ===========================================================================
  // VS CODE CONTEXT FILE - User sees this in .claude/ralph-context.md
  // ===========================================================================

  describe("VS Code Context File (what user reads)", () => {
    it("should include project name in header", () => {
      const prd = createMockPRD({
        projectName: "My Awesome App",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task 1", status: "backlog" }],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Can identify which project this is for
      expect(context).toContain("# Ralph Context - My Awesome App");
    });

    it("should include epic title when working on epic", () => {
      const prd = createMockPRD({
        projectName: "Test Project",
        projectPath: testDir,
        epicTitle: "User Authentication",
        tickets: [{ id: "t-1", title: "Add login", status: "backlog" }],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Epic context is visible
      expect(context).toContain("**Epic:** User Authentication");
    });

    it("should list incomplete tickets with their IDs", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [
          { id: "abc-123", title: "Add feature X", status: "backlog", priority: "high" },
          { id: "def-456", title: "Fix bug Y", status: "in_progress" },
        ],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Can see what needs to be done
      expect(context).toContain("**Incomplete (2):**");
      expect(context).toContain("**Add feature X** (high)");
      expect(context).toContain("ID: `abc-123`");
      expect(context).toContain("**Fix bug Y**");
      expect(context).toContain("ID: `def-456`");
    });

    it("should show completed tickets separately", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [
          { id: "t-1", title: "Done Task", status: "done" },
          { id: "t-2", title: "Pending Task", status: "backlog" },
        ],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Can see progress at a glance
      expect(context).toContain("**Incomplete (1):**");
      expect(context).toContain("**Completed (1):** Done Task");
    });

    it("should include 8-step workflow instructions", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task", status: "backlog" }],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Clear instructions for Claude to follow
      expect(context).toContain("1. **Read PRD**");
      expect(context).toContain("2. **Read Progress**");
      expect(context).toContain("3. **Pick ONE ticket**");
      expect(context).toContain("4. **Start work**");
      expect(context).toContain("5. **Implement**");
      expect(context).toContain("6. **Commit**");
      expect(context).toContain("7. **Complete**");
      expect(context).toContain("8. **Repeat**");
    });

    it("should include MCP tools reference", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task", status: "backlog" }],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Claude knows which tools to use
      expect(context).toContain("start_ticket_work(ticketId)");
      expect(context).toContain("complete_ticket_work(ticketId, summary)");
      expect(context).toContain("add_ticket_comment");
    });

    it("should include rules section for Ralph", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task", status: "backlog" }],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Ralph follows the rules
      expect(context).toContain("ONE ticket per iteration");
      expect(context).toContain("Run tests before completing");
      expect(context).toContain("Keep changes minimal and focused");
    });

    it("should show 'No incomplete tickets' when all done", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [
          { id: "t-1", title: "Task 1", status: "done" },
          { id: "t-2", title: "Task 2", status: "done" },
        ],
      });

      const context = generateVSCodeContext(prd);

      // User expectation: Clear indication that work is complete
      expect(context).toContain("**Incomplete (0):**");
      expect(context).toContain("_No incomplete tickets_");
      expect(context).toContain("**Completed (2):**");
    });
  });

  // ===========================================================================
  // CONTEXT FILE WRITING - File exists where user expects
  // ===========================================================================

  describe("Context File Writing (file system behavior)", () => {
    it("should write context file to .claude/ralph-context.md", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task", status: "backlog" }],
      });

      const content = generateVSCodeContext(prd);

      // Simulate writeVSCodeContext behavior
      const claudeDir = join(testDir, ".claude");
      mkdirSync(claudeDir, { recursive: true });
      const contextPath = join(claudeDir, "ralph-context.md");
      writeFileSync(contextPath, content, "utf-8");

      // User expectation: File exists in the right place
      expect(existsSync(contextPath)).toBe(true);

      // User expectation: File has the right content
      const savedContent = readFileSync(contextPath, "utf-8");
      expect(savedContent).toContain("# Ralph Context");
      expect(savedContent).toContain("Task");
    });

    it("should create .claude directory if it does not exist", () => {
      const prd = createMockPRD({
        projectName: "Test",
        projectPath: testDir,
        tickets: [{ id: "t-1", title: "Task", status: "backlog" }],
      });

      const content = generateVSCodeContext(prd);

      // Simulate writeVSCodeContext - directory should not exist initially
      const claudeDir = join(testDir, ".claude");
      expect(existsSync(claudeDir)).toBe(false);

      // Write file (simulating the function)
      mkdirSync(claudeDir, { recursive: true });
      writeFileSync(join(claudeDir, "ralph-context.md"), content, "utf-8");

      // User expectation: Directory was created
      expect(existsSync(claudeDir)).toBe(true);
    });
  });
});
